{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar vue = require('vue');\nvar core = require('@vueuse/core');\nrequire('../../../utils/index.js');\nrequire('../../../constants/index.js');\nvar index$1 = require('../../icon/index.js');\nvar iconsVue = require('@element-plus/icons-vue');\nrequire('../../../hooks/index.js');\nvar tabBar = require('./tab-bar2.js');\nvar constants = require('./constants.js');\nvar runtime = require('../../../utils/vue/props/runtime.js');\nvar typescript = require('../../../utils/typescript.js');\nvar error = require('../../../utils/error.js');\nvar index = require('../../../hooks/use-namespace/index.js');\nvar strings = require('../../../utils/strings.js');\nvar aria = require('../../../constants/aria.js');\nconst tabNavProps = runtime.buildProps({\n  panes: {\n    type: runtime.definePropType(Array),\n    default: () => typescript.mutable([])\n  },\n  currentName: {\n    type: [String, Number],\n    default: \"\"\n  },\n  editable: Boolean,\n  type: {\n    type: String,\n    values: [\"card\", \"border-card\", \"\"],\n    default: \"\"\n  },\n  stretch: Boolean\n});\nconst tabNavEmits = {\n  tabClick: (tab, tabName, ev) => ev instanceof Event,\n  tabRemove: (tab, ev) => ev instanceof Event\n};\nconst COMPONENT_NAME = \"ElTabNav\";\nconst TabNav = vue.defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  emits: tabNavEmits,\n  setup(props, {\n    expose,\n    emit\n  }) {\n    const vm = vue.getCurrentInstance();\n    const rootTabs = vue.inject(constants.tabsRootContextKey);\n    if (!rootTabs) error.throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`);\n    const ns = index.useNamespace(\"tabs\");\n    const visibility = core.useDocumentVisibility();\n    const focused = core.useWindowFocus();\n    const navScroll$ = vue.ref();\n    const nav$ = vue.ref();\n    const el$ = vue.ref();\n    const tabBarRef = vue.ref();\n    const scrollable = vue.ref(false);\n    const navOffset = vue.ref(0);\n    const isFocus = vue.ref(false);\n    const focusable = vue.ref(true);\n    const sizeName = vue.computed(() => [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition) ? \"width\" : \"height\");\n    const navStyle = vue.computed(() => {\n      const dir = sizeName.value === \"width\" ? \"X\" : \"Y\";\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`\n      };\n    });\n    const scrollPrev = () => {\n      if (!navScroll$.value) return;\n      const containerSize = navScroll$.value[`offset${strings.capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (!currentOffset) return;\n      const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n      navOffset.value = newOffset;\n    };\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return;\n      const navSize = nav$.value[`offset${strings.capitalize(sizeName.value)}`];\n      const containerSize = navScroll$.value[`offset${strings.capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (navSize - currentOffset <= containerSize) return;\n      const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;\n      navOffset.value = newOffset;\n    };\n    const scrollToActiveTab = async () => {\n      const nav = nav$.value;\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return;\n      await vue.nextTick();\n      const activeTab = el$.value.querySelector(\".is-active\");\n      if (!activeTab) return;\n      const navScroll = navScroll$.value;\n      const isHorizontal = [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition);\n      const activeTabBounding = activeTab.getBoundingClientRect();\n      const navScrollBounding = navScroll.getBoundingClientRect();\n      const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n      const currentOffset = navOffset.value;\n      let newOffset = currentOffset;\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n        }\n      }\n      newOffset = Math.max(newOffset, 0);\n      navOffset.value = Math.min(newOffset, maxOffset);\n    };\n    const update = () => {\n      var _a;\n      if (!nav$.value || !navScroll$.value) return;\n      props.stretch && ((_a = tabBarRef.value) == null ? void 0 : _a.update());\n      const navSize = nav$.value[`offset${strings.capitalize(sizeName.value)}`];\n      const containerSize = navScroll$.value[`offset${strings.capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (containerSize < navSize) {\n        scrollable.value = scrollable.value || {};\n        scrollable.value.prev = currentOffset;\n        scrollable.value.next = currentOffset + containerSize < navSize;\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize;\n        }\n      } else {\n        scrollable.value = false;\n        if (currentOffset > 0) {\n          navOffset.value = 0;\n        }\n      }\n    };\n    const changeTab = e => {\n      const code = e.code;\n      const {\n        up,\n        down,\n        left,\n        right\n      } = aria.EVENT_CODE;\n      if (![up, down, left, right].includes(code)) return;\n      const tabList = Array.from(e.currentTarget.querySelectorAll(\"[role=tab]:not(.is-disabled)\"));\n      const currentIndex = tabList.indexOf(e.target);\n      let nextIndex;\n      if (code === left || code === up) {\n        if (currentIndex === 0) {\n          nextIndex = tabList.length - 1;\n        } else {\n          nextIndex = currentIndex - 1;\n        }\n      } else {\n        if (currentIndex < tabList.length - 1) {\n          nextIndex = currentIndex + 1;\n        } else {\n          nextIndex = 0;\n        }\n      }\n      tabList[nextIndex].focus({\n        preventScroll: true\n      });\n      tabList[nextIndex].click();\n      setFocus();\n    };\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true;\n    };\n    const removeFocus = () => isFocus.value = false;\n    vue.watch(visibility, visibility2 => {\n      if (visibility2 === \"hidden\") {\n        focusable.value = false;\n      } else if (visibility2 === \"visible\") {\n        setTimeout(() => focusable.value = true, 50);\n      }\n    });\n    vue.watch(focused, focused2 => {\n      if (focused2) {\n        setTimeout(() => focusable.value = true, 50);\n      } else {\n        focusable.value = false;\n      }\n    });\n    core.useResizeObserver(el$, update);\n    vue.onMounted(() => setTimeout(() => scrollToActiveTab(), 0));\n    vue.onUpdated(() => update());\n    expose({\n      scrollToActiveTab,\n      removeFocus\n    });\n    vue.watch(() => props.panes, () => vm.update(), {\n      flush: \"post\",\n      deep: true\n    });\n    return () => {\n      const scrollBtn = scrollable.value ? [vue.createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-prev\"), ns.is(\"disabled\", !scrollable.value.prev)],\n        \"onClick\": scrollPrev\n      }, [vue.createVNode(index$1.ElIcon, null, {\n        default: () => [vue.createVNode(iconsVue.ArrowLeft, null, null)]\n      })]), vue.createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-next\"), ns.is(\"disabled\", !scrollable.value.next)],\n        \"onClick\": scrollNext\n      }, [vue.createVNode(index$1.ElIcon, null, {\n        default: () => [vue.createVNode(iconsVue.ArrowRight, null, null)]\n      })])] : null;\n      const tabs = props.panes.map((pane, index) => {\n        var _a, _b, _c, _d;\n        const uid = pane.uid;\n        const disabled = pane.props.disabled;\n        const tabName = (_b = (_a = pane.props.name) != null ? _a : pane.index) != null ? _b : `${index}`;\n        const closable = !disabled && (pane.isClosable || props.editable);\n        pane.index = `${index}`;\n        const btnClose = closable ? vue.createVNode(index$1.ElIcon, {\n          \"class\": \"is-icon-close\",\n          \"onClick\": ev => emit(\"tabRemove\", pane, ev)\n        }, {\n          default: () => [vue.createVNode(iconsVue.Close, null, null)]\n        }) : null;\n        const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;\n        const tabindex = !disabled && pane.active ? 0 : -1;\n        return vue.createVNode(\"div\", {\n          \"ref\": `tab-${uid}`,\n          \"class\": [ns.e(\"item\"), ns.is(rootTabs.props.tabPosition), ns.is(\"active\", pane.active), ns.is(\"disabled\", disabled), ns.is(\"closable\", closable), ns.is(\"focus\", isFocus.value)],\n          \"id\": `tab-${tabName}`,\n          \"key\": `tab-${uid}`,\n          \"aria-controls\": `pane-${tabName}`,\n          \"role\": \"tab\",\n          \"aria-selected\": pane.active,\n          \"tabindex\": tabindex,\n          \"onFocus\": () => setFocus(),\n          \"onBlur\": () => removeFocus(),\n          \"onClick\": ev => {\n            removeFocus();\n            emit(\"tabClick\", pane, tabName, ev);\n          },\n          \"onKeydown\": ev => {\n            if (closable && (ev.code === aria.EVENT_CODE.delete || ev.code === aria.EVENT_CODE.backspace)) {\n              emit(\"tabRemove\", pane, ev);\n            }\n          }\n        }, [...[tabLabelContent, btnClose]]);\n      });\n      return vue.createVNode(\"div\", {\n        \"ref\": el$,\n        \"class\": [ns.e(\"nav-wrap\"), ns.is(\"scrollable\", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]\n      }, [scrollBtn, vue.createVNode(\"div\", {\n        \"class\": ns.e(\"nav-scroll\"),\n        \"ref\": navScroll$\n      }, [vue.createVNode(\"div\", {\n        \"class\": [ns.e(\"nav\"), ns.is(rootTabs.props.tabPosition), ns.is(\"stretch\", props.stretch && [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition))],\n        \"ref\": nav$,\n        \"style\": navStyle.value,\n        \"role\": \"tablist\",\n        \"onKeydown\": changeTab\n      }, [...[!props.type ? vue.createVNode(tabBar[\"default\"], {\n        \"ref\": tabBarRef,\n        \"tabs\": [...props.panes]\n      }, null) : null, tabs]])])]);\n    };\n  }\n});\nexports[\"default\"] = TabNav;\nexports.tabNavEmits = tabNavEmits;\nexports.tabNavProps = tabNavProps;","map":{"version":3,"names":["tabNavProps","runtime","buildProps","panes","type","definePropType","Array","default","typescript","mutable","currentName","String","Number","editable","Boolean","values","stretch","tabNavEmits","tabClick","tab","tabName","ev","Event","tabRemove","COMPONENT_NAME","TabNav","vue","defineComponent","name","props","emits","expose","emit","vm","getCurrentInstance","rootTabs","inject","constants","tabsRootContextKey","error","throwError","ns","index","useNamespace","visibility","core","useDocumentVisibility","focused","useWindowFocus","navScroll$","ref","nav$","el$","tabBarRef","scrollable","navOffset","isFocus","focusable","sizeName","computed","includes","tabPosition","navStyle","dir","value","transform","containerSize","strings","capitalize","currentOffset","newOffset","scrollNext","navSize","scrollToActiveTab","nav","nextTick","activeTab","querySelector","navScroll","isHorizontal","activeTabBounding","getBoundingClientRect","navScrollBounding","left","right","top","bottom","Math","min","maxOffset","update","_a","prev","next","changeTab","e","code","down","aria","EVENT_CODE","up","tabList","from","currentTarget","querySelectorAll","currentIndex","indexOf","target","nextIndex","length","focus","preventScroll","click","setFocus","removeFocus","watch","visibility2","focused2","setTimeout","useResizeObserver","flush","scrollBtn","createVNode","is","scrollPrev","index$1","ElIcon","onUpdated","iconsVue","ArrowLeft","ArrowRight","tabs","map","pane","_b","_c","_d","uid","disabled","closable","isClosable","btnClose","Close","tabLabelContent","slots","label","call","tabindex","active","onFocus","onBlur","delete","backspace","tabBar"],"sources":["../../../../../../packages/components/tabs/src/tab-nav.tsx"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  inject,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  watch,\n} from 'vue'\nimport {\n  useDocumentVisibility,\n  useResizeObserver,\n  useWindowFocus,\n} from '@vueuse/core'\nimport {\n  buildProps,\n  capitalize,\n  definePropType,\n  mutable,\n  throwError,\n} from '@element-plus/utils'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { ElIcon } from '@element-plus/components/icon'\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue'\nimport { useNamespace } from '@element-plus/hooks'\nimport TabBar from './tab-bar.vue'\nimport { tabsRootContextKey } from './constants'\n\nimport type { CSSProperties, ExtractPropTypes } from 'vue'\nimport type { TabsPaneContext } from './constants'\nimport type { TabPaneName } from './tabs'\n\ninterface Scrollable {\n  next?: boolean\n  prev?: number\n}\n\nexport const tabNavProps = buildProps({\n  panes: {\n    type: definePropType<TabsPaneContext[]>(Array),\n    default: () => mutable([] as const),\n  },\n  currentName: {\n    type: [String, Number],\n    default: '',\n  },\n  editable: Boolean,\n  type: {\n    type: String,\n    values: ['card', 'border-card', ''],\n    default: '',\n  },\n  stretch: Boolean,\n} as const)\n\nexport const tabNavEmits = {\n  tabClick: (tab: TabsPaneContext, tabName: TabPaneName, ev: Event) =>\n    ev instanceof Event,\n  tabRemove: (tab: TabsPaneContext, ev: Event) => ev instanceof Event,\n}\n\nexport type TabNavProps = ExtractPropTypes<typeof tabNavProps>\nexport type TabNavEmits = typeof tabNavEmits\n\nconst COMPONENT_NAME = 'ElTabNav'\nconst TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  emits: tabNavEmits,\n  setup(props, { expose, emit }) {\n    const vm = getCurrentInstance()!\n\n    const rootTabs = inject(tabsRootContextKey)\n    if (!rootTabs) throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`)\n\n    const ns = useNamespace('tabs')\n    const visibility = useDocumentVisibility()\n    const focused = useWindowFocus()\n\n    const navScroll$ = ref<HTMLDivElement>()\n    const nav$ = ref<HTMLDivElement>()\n    const el$ = ref<HTMLDivElement>()\n\n    const tabBarRef = ref<InstanceType<typeof TabBar>>()\n\n    const scrollable = ref<false | Scrollable>(false)\n    const navOffset = ref(0)\n    const isFocus = ref(false)\n    const focusable = ref(true)\n\n    const sizeName = computed(() =>\n      ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n        ? 'width'\n        : 'height'\n    )\n    const navStyle = computed<CSSProperties>(() => {\n      const dir = sizeName.value === 'width' ? 'X' : 'Y'\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`,\n      }\n    })\n\n    const scrollPrev = () => {\n      if (!navScroll$.value) return\n\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (!currentOffset) return\n\n      const newOffset =\n        currentOffset > containerSize ? currentOffset - containerSize : 0\n\n      navOffset.value = newOffset\n    }\n\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (navSize - currentOffset <= containerSize) return\n\n      const newOffset =\n        navSize - currentOffset > containerSize * 2\n          ? currentOffset + containerSize\n          : navSize - containerSize\n\n      navOffset.value = newOffset\n    }\n\n    const scrollToActiveTab = async () => {\n      const nav = nav$.value\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return\n\n      await nextTick()\n\n      const activeTab = el$.value.querySelector('.is-active')\n      if (!activeTab) return\n\n      const navScroll = navScroll$.value\n      const isHorizontal = ['top', 'bottom'].includes(\n        rootTabs.props.tabPosition\n      )\n      const activeTabBounding = activeTab.getBoundingClientRect()\n      const navScrollBounding = navScroll.getBoundingClientRect()\n      const maxOffset = isHorizontal\n        ? nav.offsetWidth - navScrollBounding.width\n        : nav.offsetHeight - navScrollBounding.height\n      const currentOffset = navOffset.value\n      let newOffset = currentOffset\n\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset =\n            currentOffset - (navScrollBounding.left - activeTabBounding.left)\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset =\n            currentOffset + activeTabBounding.right - navScrollBounding.right\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset =\n            currentOffset - (navScrollBounding.top - activeTabBounding.top)\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset =\n            currentOffset +\n            (activeTabBounding.bottom - navScrollBounding.bottom)\n        }\n      }\n      newOffset = Math.max(newOffset, 0)\n      navOffset.value = Math.min(newOffset, maxOffset)\n    }\n\n    const update = () => {\n      if (!nav$.value || !navScroll$.value) return\n\n      props.stretch && tabBarRef.value?.update()\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (containerSize < navSize) {\n        scrollable.value = scrollable.value || {}\n        scrollable.value.prev = currentOffset\n        scrollable.value.next = currentOffset + containerSize < navSize\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize\n        }\n      } else {\n        scrollable.value = false\n        if (currentOffset > 0) {\n          navOffset.value = 0\n        }\n      }\n    }\n\n    const changeTab = (e: KeyboardEvent) => {\n      const code = e.code\n\n      const { up, down, left, right } = EVENT_CODE\n      if (![up, down, left, right].includes(code)) return\n\n      // 左右上下键更换tab\n      const tabList = Array.from(\n        (e.currentTarget as HTMLDivElement).querySelectorAll<HTMLDivElement>(\n          '[role=tab]:not(.is-disabled)'\n        )\n      )\n      const currentIndex = tabList.indexOf(e.target as HTMLDivElement)\n\n      let nextIndex: number\n      if (code === left || code === up) {\n        // left\n        if (currentIndex === 0) {\n          // first\n          nextIndex = tabList.length - 1\n        } else {\n          nextIndex = currentIndex - 1\n        }\n      } else {\n        // right\n        if (currentIndex < tabList.length - 1) {\n          // not last\n          nextIndex = currentIndex + 1\n        } else {\n          nextIndex = 0\n        }\n      }\n      tabList[nextIndex].focus({ preventScroll: true }) // 改变焦点元素\n      tabList[nextIndex].click() // 选中下一个tab\n      setFocus()\n    }\n\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true\n    }\n    const removeFocus = () => (isFocus.value = false)\n\n    watch(visibility, (visibility) => {\n      if (visibility === 'hidden') {\n        focusable.value = false\n      } else if (visibility === 'visible') {\n        setTimeout(() => (focusable.value = true), 50)\n      }\n    })\n    watch(focused, (focused) => {\n      if (focused) {\n        setTimeout(() => (focusable.value = true), 50)\n      } else {\n        focusable.value = false\n      }\n    })\n\n    useResizeObserver(el$, update)\n\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0))\n    onUpdated(() => update())\n\n    expose({\n      scrollToActiveTab,\n      removeFocus,\n    })\n\n    watch(\n      () => props.panes,\n      () => vm.update(),\n      { flush: 'post', deep: true }\n    )\n\n    return () => {\n      const scrollBtn = scrollable.value\n        ? [\n            <span\n              class={[\n                ns.e('nav-prev'),\n                ns.is('disabled', !scrollable.value.prev),\n              ]}\n              onClick={scrollPrev}\n            >\n              <ElIcon>\n                <ArrowLeft />\n              </ElIcon>\n            </span>,\n            <span\n              class={[\n                ns.e('nav-next'),\n                ns.is('disabled', !scrollable.value.next),\n              ]}\n              onClick={scrollNext}\n            >\n              <ElIcon>\n                <ArrowRight />\n              </ElIcon>\n            </span>,\n          ]\n        : null\n\n      const tabs = props.panes.map((pane, index) => {\n        const uid = pane.uid\n        const disabled = pane.props.disabled\n        const tabName = pane.props.name ?? pane.index ?? `${index}`\n        const closable = !disabled && (pane.isClosable || props.editable)\n        pane.index = `${index}`\n\n        const btnClose = closable ? (\n          <ElIcon\n            class=\"is-icon-close\"\n            // `onClick` not exist when generate dts\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            onClick={(ev: MouseEvent) => emit('tabRemove', pane, ev)}\n          >\n            <Close />\n          </ElIcon>\n        ) : null\n\n        const tabLabelContent = pane.slots.label?.() || pane.props.label\n        const tabindex = !disabled && pane.active ? 0 : -1\n\n        return (\n          <div\n            ref={`tab-${uid}`}\n            class={[\n              ns.e('item'),\n              ns.is(rootTabs.props.tabPosition),\n              ns.is('active', pane.active),\n              ns.is('disabled', disabled),\n              ns.is('closable', closable),\n              ns.is('focus', isFocus.value),\n            ]}\n            id={`tab-${tabName}`}\n            key={`tab-${uid}`}\n            aria-controls={`pane-${tabName}`}\n            role=\"tab\"\n            aria-selected={pane.active}\n            tabindex={tabindex}\n            onFocus={() => setFocus()}\n            onBlur={() => removeFocus()}\n            onClick={(ev: MouseEvent) => {\n              removeFocus()\n              emit('tabClick', pane, tabName, ev)\n            }}\n            onKeydown={(ev: KeyboardEvent) => {\n              if (\n                closable &&\n                (ev.code === EVENT_CODE.delete ||\n                  ev.code === EVENT_CODE.backspace)\n              ) {\n                emit('tabRemove', pane, ev)\n              }\n            }}\n          >\n            {...[tabLabelContent, btnClose]}\n          </div>\n        )\n      })\n\n      return (\n        <div\n          ref={el$}\n          class={[\n            ns.e('nav-wrap'),\n            ns.is('scrollable', !!scrollable.value),\n            ns.is(rootTabs.props.tabPosition),\n          ]}\n        >\n          {scrollBtn}\n          <div class={ns.e('nav-scroll')} ref={navScroll$}>\n            <div\n              class={[\n                ns.e('nav'),\n                ns.is(rootTabs.props.tabPosition),\n                ns.is(\n                  'stretch',\n                  props.stretch &&\n                    ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n                ),\n              ]}\n              ref={nav$}\n              style={navStyle.value}\n              role=\"tablist\"\n              onKeydown={changeTab}\n            >\n              {...[\n                !props.type ? (\n                  <TabBar ref={tabBarRef} tabs={[...props.panes]} />\n                ) : null,\n                tabs,\n              ]}\n            </div>\n          </div>\n        </div>\n      )\n    }\n  },\n})\n\nexport type TabNavInstance = InstanceType<typeof TabNav> & {\n  scrollToActiveTab: () => Promise<void>\n  removeFocus: () => void\n}\nexport default TabNav\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAuCa,MAAAA,WAAW,GAAGC,OAAA,CAAAC,UAAU,CAAC;EACpCC,KAAK,EAAE;IACLC,IAAI,EAAEH,OAAA,CAAAI,cAAc,CAAoBC,KAApB,CADf;IAELC,OAAO,EAAEA,CAAA,KAAMC,UAAA,CAAAC,OAAO,CAAC,EAAD;GAHY;EAKpCC,WAAW,EAAE;IACXN,IAAI,EAAE,CAACO,MAAD,EAASC,MAAT,CADK;IAEXL,OAAO,EAAE;GAPyB;EASpCM,QAAQ,EAAEC,OAT0B;EAUpCV,IAAI,EAAE;IACJA,IAAI,EAAEO,MADF;IAEJI,MAAM,EAAE,CAAC,MAAD,EAAS,aAAT,EAAwB,EAAxB,CAFJ;IAGJR,OAAO,EAAE;GAbyB;EAepCS,OAAO,EAAEF;AAf2B,CAAD;AAkB9B,MAAMG,WAAW,GAAG;EACzBC,QAAQ,EAAEA,CAACC,GAAD,EAAuBC,OAAvB,EAA6CC,EAA7C,KACRA,EAAE,YAAYC,KAFS;EAGzBC,SAAS,EAAEA,CAACJ,GAAD,EAAuBE,EAAvB,KAAqCA,EAAE,YAAYC;AAHrC;AAS3B,MAAME,cAAc,GAAG,UAAvB;AACM,MAAAC,MAAM,GAAGC,GAAA,CAAAC,eAAe,CAAC;EAC7BC,IAAI,EAAEJ,cADuB;EAE7BK,KAAK,EAAE7B,WAFsB;EAG7B8B,KAAK,EAAEb,WAHsB;;IAIxBc,MAAA;IAAUC;EAAQ;IAAQ,MAAAC,EAAA,GAAAP,GAAA,CAAAQ,kBAAA;IAC7B,MAAMC,QAAK,GAAAT,GAAA,CAAAU,MAAA,CAAAC,SAAA,CAAAC,kBAAX;IAEA,KAAAH,QAAc,EACVI,KAAA,CAAAC,UAAA,CAAJhB,cAAyB;IAEzB,MAAMiB,EAAE,GAAGC,KAAA,CAAAC,YAAY,CAAC,MAAD,CAAvB;IACA,MAAMC,UAAU,GAAGC,IAAA,CAAAC,qBAAqB,EAAxC;IACA,MAAMC,OAAO,GAAGF,IAAA,CAAAG,cAAc,EAA9B;IAEA,MAAMC,UAAU,GAAGvB,GAAA,CAAAwB,GAAG,EAAtB;IACA,MAAMC,IAAI,GAAGzB,GAAA,CAAAwB,GAAG,EAAhB;IACA,MAAME,GAAG,GAAG1B,GAAA,CAAAwB,GAAG,EAAf;IAEA,MAAMG,SAAS,GAAG3B,GAAA,CAAAwB,GAAG,EAArB;IAEA,MAAMI,UAAU,GAAG5B,GAAA,CAAAwB,GAAG,CAAqB,KAArB,CAAtB;IACA,MAAMK,SAAS,GAAG7B,GAAA,CAAAwB,GAAG,CAAC,CAAD,CAArB;IACA,MAAMM,OAAO,GAAG9B,GAAA,CAAAwB,GAAG,CAAC,KAAD,CAAnB;IACA,MAAMO,SAAS,GAAG/B,GAAA,CAAAwB,GAAG,CAAC,IAAD,CAArB;IAEA,MAAMQ,QAAQ,GAAGhC,GAAA,CAAAiC,QAAQ,CAAC,MACxB,CAAC,KAAD,EAAQ,QAAR,EAAkBC,QAAlB,CAA2BzB,QAAQ,CAACN,KAAT,CAAegC,WAA1C,CACI,UADJ,GAEI,QAHmB,CAAzB;IAKA,MAAMC,QAAQ,GAAGpC,GAAA,CAAAiC,QAAQ,CAAgB,MAAM;MAC7C,MAAMI,GAAG,GAAGL,QAAQ,CAACM,KAAT,KAAmB,OAAnB,GAA6B,GAA7B,GAAmC,GAA/C;MACA,OAAO;QACLC,SAAS,EAAc,YAAAF,GAAQ,KAAAR,SAAS,CAACS,KAAM;OADjD;IAGD,CALwB,CAAzB;;MAOM,KAAAf,UAAA,CAAAe,KAAmB,EACvB;MAEA,MAAME,aAAa,GACjBjB,UAAU,CAACe,KAAX,CAAkB,SAAQG,OAAA,CAAAC,UAAU,CAACV,QAAQ,CAACM,KAAV,CAAiB,EAArD,CADF;MAEA,MAAMK,aAAa,GAAGd,SAAS,CAACS,KAAhC;MAEA,IAAI,CAACK,aAAL,EAEM;MAGN,MAASC,SAAT,GAAkBD,aAAlB,GAAAH,aAAA,GAAAG,aAAA,GAAAH,aAAA;MAZFX,SAAA,CAAAS,KAAA,GAAAM,SAAA;;IAeA,MAAMC,UAAU,GAAGA,CAAA,KAAM;MACvB,IAAI,CAACtB,UAAU,CAACe,KAAZ,IAAqB,CAACb,IAAI,CAACa,KAA/B,EAEA;MACA,MAAMQ,OAAa,GAAArB,IAAA,CAAAa,KACP,UAAAG,OAAA,CAAAC,UAAQ,CAAAV,QAAkB,CAAAM,KAAS;MAC/C,MAAME,aAAa,GAAGjB,UAAU,CAAhCe,KAAA,UAAAG,OAAA,CAAAC,UAAA,CAAAV,QAAA,CAAAM,KAAA;MAEA,MAAWK,aAAP,GAAAd,SAA2B,CAAAS,KAAA;MAE/B,IAAAQ,OAAA,GAAAH,aACY,IAAAH,aAAgB,EAInB;MAfX,MAAAI,SAAA,GAAAE,OAAA,GAAAH,aAAA,GAAAH,aAAA,OAAAG,aAAA,GAAAH,aAAA,GAAAM,OAAA,GAAAN,aAAA;;KAkBM;IACJ,MAAAO,iBAAA,SAAAA,CAAA;MACA,MAAeC,GAAA,GAAAvB,IAAC,CAAZa,KAAA;MAEJ,KAAAV,UAAA,CAAAU,KAAA,KAAAZ,GAAA,CAAAY,KAAA,KAAAf,UAAA,CAAAe,KAAA,KAAAU,GAAA,EAEM;MACN,MAAAhD,GAAA,CAAAiD,QAAA,EAAgB;MAEhB,MAAMC,SAAS,GAAGxB,GAAU,CAAAY,KAAA,CAAAa,aAA5B;MACA,KAAAD,SAAkB,EAGlB;MACA,MAAME,SAAiB,GAAA7B,UAAY,CAAAe,KAAA;MACnC,MAAMe,YAAY,mBACV,EAAAnB,QAAA,CAAJzB,QAAkB,CAAAN,KAAA,CAAAgC,WADQ;MAG9B,MAAMmB,iBAAyB,GAAAJ,SAA/B,CAAAK,qBAAA;MACA,MAAIC,iBAAJ,GAAAJ,SAAA,CAAAG,qBAAA;;MAEA,MAAAZ,aAAkB,GAAAd,SAAA,CAAAS,KAAA;MAChB,IAAAM,SAAA,GAAAD,aAAA;UACEU,YACE,EAAa;QAChB,IAAAC,iBAAA,CAAAG,IAAA,GAAAD,iBAAA,CAAAC,IAAA;;QACD;YACWH,iBAAA,CAAAI,KACM,GAAGF,iBAAiB,CAACE,KAAlC;UACHd,SAAA,GAAAD,aAAA,GAAAW,iBAAA,CAAAI,KAAA,GAAAF,iBAAA,CAAAE,KAAA;QACF;MACC;YACWJ,iBACM,CAAAK,GAAA,GAAAH,iBAAqB,CAAAG,GAAC;UACtCf,SAAA,GAAAD,aAAA,IAAAa,iBAAA,CAAAG,GAAA,GAAAL,iBAAA,CAAAK,GAAA;;QACD,IAAIL,iBAAiB,CAACM,MAAlB,GAA2BJ,iBAAiB,CAACI,MAAjD,EAAyD;UACvDhB,SAAS,GACPD,aAAa,IACZW,iBAAiB,CAACM,MAAlB,GAA2BJ,iBAAiB,CAACI,MADjC,CADf;QAGD;MACF;;MACD/B,SAAS,CAAAS,KAAA,GAAQuB,IAAL,CAAAC,GAAA,CAAAlB,SAAZ,EAAAmB,SAAA;;IAED,MA3CDC,MAAA,GAAAA,CAAA;;MA6CM,KAAAvC,IAAA,CAAMa,KAAS,KAAAf,UAAA,CAAAe,KAAA,EACf;MAEJnC,KAAK,CAACb,OAAN,KAAiB,CAAA2E,EAAA,GAAAtC,SAAA,CAAiBW,KAAA,KAAlC,gBAAA2B,EAAA,CAAAD,MAAA;MAEA,MAAMlB,OAAO,GAAGrB,IAAI,CAACa,KAAL,CAAY,SAAQG,OAAA,CAAAC,UAAU,CAACV,QAAQ,CAACM,KAAV,CAAiB,EAA/C,CAAhB;MACA,MAAME,aAAa,GACjBjB,UAAU,CAACe,KAAX,CAAkB,SAAQG,OAAA,CAAAC,UAAU,CAACV,QAAQ,CAACM,KAAV,CAAiB,EAArD,CADF;MAEA,MAAMK,aAAa,GAAGd,SAAS,CAACS,KAAhC;;QAEIV,UAAA,CAAAU,KAAgB,GAAAV,UAAS,CAAAU,KAAA;QAC3BV,UAAU,CAACU,KAAX,CAAA4B,IAAA,GAAAvB,aAAA;QACAf,UAAU,CAACU,KAAX,CAAiB6B,IAAjB,GAAwBxB,aAAxB,GAAAH,aAAA,GAAAM,OAAA;QACA,IAAUA,OAAC,GAAAH,aAA0B,GAAAH,aAAb;;QACxB;MACE;QACDZ,UAAA,CAAAU,KAAA;QACI,IAAAK,aAAA;UACKd,SAAC,CAAXS,KAAA;;;;IAGC,MAAA8B,SAAA,GAAAC,CAAA;MACF,MAAAC,IAAA,GAAAD,CAAA,CAAAC,IAAA;MAtBH;;QAyBMC,IAAA;QACJd,IAAM;QAEAC;UAAAc,IAAA,CAAAC,UAAA;UAAA,EAAAC,EAAA,EAAAH,IAAA,EAAAd,IAAA,EAAAC,KAAA,EAAAxB,QAAA,CAAAoC,IAAA,GAAY;MAAM,MAAAK,OAAA,GAAA/F,KAAA,CAAAgG,IAAA,CAAAP,CAAA,CAAAQ,aAAA,CAAAC,gBAAA;MAAlB,MAANC,YAAA,GAAAJ,OAAA,CAAAK,OAAA,CAAAX,CAAA,CAAAY,MAAA;MACA,IAAIC,SAAM;;QAGV,IAAMH,YAAe,QAAL;UAKVG,SAAA,GAAAP,OAAsB,CAAAQ,MAAA;QAE5B;;QACA;MACE;QACA,IAAIJ,YAAY,GAAKJ,OAAG,CAAAQ,MAAA;UACtBD,SAAA,GAAAH,YAAA;QACA;UACKG,SAAA;;MAEN;MACFP,OAAM,CAAAO,SAAA,EAAAE,KAAA;QACLC,aAAA;MACA;MACEV,OAAA,CAAAO,SAAA,EAAAI,KAAA;cACS;IACV;IACC,MAAAC,QAAA,GAAAA,CAAA;MACD,IAAAxD,SAAA,CAAAO,KAAA,EACFR,OAAA,CAAAQ,KAAA;;IACD,MAAAkD,WAAQ,GAARb,CAAA,KAAA7C,OAAyB,CAAAQ,KAAA;IAAEtC,GAAA,CAAAyF,KAAA,CAAAvE,UAAA,EAAewE,WAAA;MAAjB,IAAyBA,WAAA;;MAClD,OAAO,IAAAA,WAAY,KAjCmB,SAiCX;;;KAjC7B;;MAqCM,IAAAC,QAAQ;QACRC,UAAA,CAAS,MAAb7D,SAA4B,CAACO,KAAR,GAAgB,IAAhB;OADvB;;MAGA;;IAEAnB,IAAA,CAAA0E,iBAAmB,CAAAnE,GAAA,EAAAsC,MAAe;iBAC5B,OAAU4B,UAAK,OAAU7C,iBAAA;iBAClB,OAATiB,MAAkB,EAAlB;IACD3D,MAAM;;MAENmF;IACF,CANI,CAAL;IAOAxF,GAAA,CAAAyF,KAAK,CAAC,MAAAtF,KAAU,CAAA1B,KAAY,QAAA8B,EAAA,CAAAyD,MAAA;MAC1B8B,KAAA,QAAa;UACD;IACX;WACU;MACV,MAAAC,SAAA,GAAAnE,UAAA,CAAAU,KAAA,IAAAtC,GAAA,CAAAgG,WAAA;QALH,UAAAjF,EAAA,CAAAsD,CAAA,cAAAtD,EAAA,CAAAkF,EAAA,cAAArE,UAAA,CAAAU,KAAA,CAAA4B,IAAA;QAQA,WAAAgC;OAES,GAAAlG,GAAA,CAAAgG,WAAO,CAAAG,OAAA,CAAAC,MAAA,EAAW,MAAM;QACjCvH,OAAU,EAAAwH,CAAA,KAAY,CAAArG,GAAA,CAAAgG,WAAtB,CAAAM,QAAA,CAAAC,SAAA;MAEA,IAAM,EAACvG,GAAA,CAAAgG,WAAA;QAAA,UAAAjF,EAAA,CAAAsD,CAAA,cAAAtD,EAAA,CAAAkF,EAAA,cAAArE,UAAA,CAAAU,KAAA,CAAA6B,IAAA;QAEL,WAAAtB;MAFK,CAAP,GAAA7C,GAAA,CAAAgG,WAAA,CAAAG,OAAA,CAAAC,MAAA;QAKKvH,OACG,EAAAA,CAAA,KAAM,CAAAmB,GAAA,CAAAgG,WACJ,CAAAM,QAAA,CAAAE,UACR;MAAE,KAAK,GAAP;MAAiB,MAAMC,IAAA,GAAAtG,KAAA,CAAA1B,KAAA,CAAAiI,GAAA,EAAAC,IAAA,EAAA3F,KAAA;QAHzB,IAAAiD,EAAA,EAAA2C,EAAA,EAAAC,EAAA,EAAAC,EAAA;QAMA,MAAaC,GAAA,GAAAJ,IAAA,CAAAI,GAAA;QACX,MAAeC,QAAA,GAAaL,IAAA,CAAAxG,KAAC,CAAA6G,QACzB;QAAA,MAEWtH,OACF,GAAH,CAAAkH,EAAA,IAAA3C,EAAA,GACA0C,IAAA,CAAAxG,KAAM,CAAAD,IAAA,KAAa,OAAA+D,EAAU,GAAV0C,IAAiB,CAApC3F,KAJN,YAAA4F,EAAA,MAAA5F,KAAA;QAAA,MAMaiG,QAAA,IAAAD,QAAA,KAAAL,IAAA,CAAAO,UAAA,IAAA/G,KAAA,CAAAhB,QAAA;QANbwH,IAAA,CAAA3F,KAAA,MAAAA,KAAA;QAAA,MAAAmG,QAAA,GAAAF,QAAA,GAAAjH,GAAA,CAAAgG,WAAA,CAAAG,OAAA,CAAAC,MAAA;UAAA;UAaW,WACLzG,EAAA,IAAAW,IAAA,CADK,WAEC,EAAAqG,IAAA,EAAAhH,EAAa;SAEZ;UAjBbd,OAAA,EAAAA,CAAA,MAAAmB,GAAA,CAAAgG,WAAA,CAAAM,QAAA,CAAAc,KAAA;QAAA;QAAA,MAwBAC,eAzBJ,KAAAP,EAAA,IAAAD,EAAA,GAAAF,IAAA,CAAAW,KAAA,EAAAC,KAAA,qBAAAT,EAAA,CAAAU,IAAA,CAAAX,EAAA,MAAAF,IAAA,CAAAxG,KAAA,CAAAoH,KAAA;QA2BA,MAAUE,QAAQ,GAAC,CAANT,QAAA,IAAiBL,IAAM,CAAAe,MAAU;QAC5C,OAAS1H,GAAA,CAAAgG,WAAT;UACA,cAAiBe,GAAA,EAAI;UACrB,OAAa,GAAAhG,EAAA,CAAAsD,CAAG,CAAI,SAAJtD,EAAW,CAAAkF,EAAX,CAAmBxF,QAAK,CAAAN,KAAU,CAAAgC,WAAlD,GAAApB,EAAA,CAAAkF,EAAA,WAAAU,IAAA,CAAAe,MAAA,GAAA3G,EAAA,CAAAkF,EAAA,aAAAe,QAAA,GAAAjG,EAAA,CAAAkF,EAAA,aAAAgB,QAAA,GAAAlG,EAAA,CAAAkF,EAAA,UAAAnE,OAAA,CAAAQ,KAAA;UACA,IAAM,EAAQ,OAAA5C,OAAI;UAClB,KAAK,EAAL,OAAgBqH,GAAA,EAAM;UAEhB,eAAW,EAAQ,QAAArH,OAAA;UAAA;UAAA,iBAMQiH,IAAI,CAACe,MAAA;UANb,YAAAD,QAAA;UAAA,WAAAE,CAAA,KAAApC,QAAA;UAAA,QAAzB,EAAAqC,CAAA,KAAApC,WAAA;UAYA,SAAqB,EAAA7F,EAAA;YACrB6F,WAAc,EAAG;YAEjBlF,IAAA,aAAAqG,IAAA,EAAAjH,OAAA,EAAAC,EAAA;WAEU;UAFV,WAIQ,EAAFA,EAAA;YAOG,IAAAsH,QAAA,KAAAtH,EAXT,CAAA2E,IAAA,KAAAE,IAAA,CAAAC,UAAA,CAAAoD,MAAA,IAAAlI,EAAA,CAAA2E,IAAA,KAAAE,IAAA,CAAAC,UAAA,CAAAqD,SAAA;cAYUxH,IAAA,YAZV,EAAAqG,IAAA,EAAAhH,EAAA;;UAAA;WAemB,KAAA0H,eAAI,EAfvBF,QAAA;MAAA;aAiBanH,GAAA,CAAAgG,WAAA;aACD,EAAAtE,GAAA;QAlBZ,UAAAX,EAAA,CAmBcsD,CAAA,CAAD,UAAoB,GAAAtD,EAAA,CAAAkF,EAAA,iBAAArE,UAAA,CAAAU,KAAA,GAAAvB,EAAA,CAAAkF,EAAA,CAAAxF,QAAA,CAAAN,KAAA,CAAAgC,WAAA;mBAChB,EAAAnC,GAAA,CAAAgG,WAAA;eACP,EAACjF,EAAA,CAAAsD,CAAA,cAAkB;aArB7B,EAAA9C;MAAA,IAAAvB,GAAA,CAAAgG,WAAA,CAuBgB,KAAsB;QAChC,UAAAjF,EAAA,CAAAsD,CAAA,MAEG,GAAEtD,EAAF,CAAAkF,EAAA,CAAAxF,QAAA,CAAAN,KAAsB,CAACgC,WACtB,CAAE,EAAFpB,EAAA,CAAAkF,EAAA,YAAA9F,KAAuB,CAAAb,OACzB,sBAAA4C,QAAA,CAAAzB,QAAA,CAAAN,KAAA,CAAAgC,WAAA;QACA,OAAAV,IAAK;QACN,SAAAW,QAAA,CAAAE,KAAA;QACF;QA/BL,WAiCS,EAAA8B;MAGV,CA1DY,EAAb,MAAAjE,KAAA,CAAAzB,IAAA,GAAAsB,GAAA,CAAAgG,WAAA,CAAA+B,MAAA;QA4DA,OAAApG,SAAA;QAAA,YAAAxB,KAAA,CAAA1B,KAAA;MAAA,WAGW,IACF,EAAEgI,IAAA,MAAL,CADK;IAHX;EAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}