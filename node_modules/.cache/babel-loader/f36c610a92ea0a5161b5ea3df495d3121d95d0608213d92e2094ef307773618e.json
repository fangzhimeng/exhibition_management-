{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar vue = require('vue');\nrequire('../../../../utils/index.js');\nrequire('../../../../hooks/index.js');\nvar scrollbar = require('../components/scrollbar.js');\nvar useGridWheel = require('../hooks/use-grid-wheel.js');\nvar useCache = require('../hooks/use-cache.js');\nvar props = require('../props.js');\nvar utils = require('../utils.js');\nvar defaults = require('../defaults.js');\nvar index = require('../../../../hooks/use-namespace/index.js');\nvar types = require('../../../../utils/types.js');\nvar scroll = require('../../../../utils/dom/scroll.js');\nvar shared = require('@vue/shared');\nvar core = require('@vueuse/core');\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  injectToInstance,\n  validateProps\n}) => {\n  return vue.defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: props.virtualizedGridProps,\n    emits: [defaults.ITEM_RENDER_EVT, defaults.SCROLL_EVT],\n    setup(props, {\n      emit,\n      expose,\n      slots\n    }) {\n      const ns = index.useNamespace(\"vl\");\n      validateProps(props);\n      const instance = vue.getCurrentInstance();\n      const cache = vue.ref(initCache(props, instance));\n      injectToInstance == null ? void 0 : injectToInstance(instance, cache);\n      const windowRef = vue.ref();\n      const hScrollbar = vue.ref();\n      const vScrollbar = vue.ref();\n      const innerRef = vue.ref(null);\n      const states = vue.ref({\n        isScrolling: false,\n        scrollLeft: types.isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: types.isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: defaults.FORWARD,\n        yAxisScrollDir: defaults.FORWARD\n      });\n      const getItemStyleCache = useCache.useCache();\n      const parsedHeight = vue.computed(() => Number.parseInt(`${props.height}`, 10));\n      const parsedWidth = vue.computed(() => Number.parseInt(`${props.width}`, 10));\n      const columnsToRender = vue.computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          columnCache\n        } = props;\n        const {\n          isScrolling,\n          xAxisScrollDir,\n          scrollLeft\n        } = vue.unref(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, vue.unref(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, vue.unref(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === defaults.BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === defaults.FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const rowsToRender = vue.computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          rowCache\n        } = props;\n        const {\n          isScrolling,\n          yAxisScrollDir,\n          scrollTop\n        } = vue.unref(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, vue.unref(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, vue.unref(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === defaults.BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === defaults.FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalHeight = vue.computed(() => getEstimatedTotalHeight(props, vue.unref(cache)));\n      const estimatedTotalWidth = vue.computed(() => getEstimatedTotalWidth(props, vue.unref(cache)));\n      const windowStyle = vue.computed(() => {\n        var _a;\n        return [{\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        }, {\n          direction: props.direction,\n          height: types.isNumber(props.height) ? `${props.height}px` : props.height,\n          width: types.isNumber(props.width) ? `${props.width}px` : props.width\n        }, (_a = props.style) != null ? _a : {}];\n      });\n      const innerStyle = vue.computed(() => {\n        const width = `${vue.unref(estimatedTotalWidth)}px`;\n        const height = `${vue.unref(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: vue.unref(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n      const emitEvents = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = vue.unref(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = vue.unref(rowsToRender);\n          emit(defaults.ITEM_RENDER_EVT, {\n            columnCacheStart,\n            columnCacheEnd,\n            rowCacheStart,\n            rowCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n            rowVisibleStart,\n            rowVisibleEnd\n          });\n        }\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir\n        } = vue.unref(states);\n        emit(defaults.SCROLL_EVT, {\n          xAxisScrollDir,\n          scrollLeft,\n          yAxisScrollDir,\n          scrollTop,\n          updateRequested\n        });\n      };\n      const onScroll = e => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = vue.unref(states);\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n        let _scrollLeft = scrollLeft;\n        if (utils.isRTL(props.direction)) {\n          switch (utils.getRTLOffsetType()) {\n            case defaults.RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n            case defaults.RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: true,\n          xAxisScrollDir: utils.getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: utils.getScrollDir(_states.scrollTop, scrollTop)\n        };\n        vue.nextTick(() => resetIsScrolling());\n        onUpdated();\n        emitEvents();\n      };\n      const onVerticalScroll = (distance, totalSteps) => {\n        const height = vue.unref(parsedHeight);\n        const offset = (estimatedTotalHeight.value - height) / totalSteps * distance;\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)\n        });\n      };\n      const onHorizontalScroll = (distance, totalSteps) => {\n        const width = vue.unref(parsedWidth);\n        const offset = (estimatedTotalWidth.value - width) / totalSteps * distance;\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)\n        });\n      };\n      const {\n        onWheel\n      } = useGridWheel.useGridWheel({\n        atXStartEdge: vue.computed(() => states.value.scrollLeft <= 0),\n        atXEndEdge: vue.computed(() => states.value.scrollLeft >= estimatedTotalWidth.value - vue.unref(parsedWidth)),\n        atYStartEdge: vue.computed(() => states.value.scrollTop <= 0),\n        atYEndEdge: vue.computed(() => states.value.scrollTop >= estimatedTotalHeight.value - vue.unref(parsedHeight))\n      }, (x, y) => {\n        var _a, _b, _c, _d;\n        (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);\n        (_d = (_c = vScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);\n        const width = vue.unref(parsedWidth);\n        const height = vue.unref(parsedHeight);\n        scrollTo({\n          scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),\n          scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)\n        });\n      });\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n        const _states = vue.unref(states);\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n        states.value = {\n          ..._states,\n          xAxisScrollDir: utils.getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: utils.getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        };\n        vue.nextTick(() => resetIsScrolling());\n        onUpdated();\n        emitEvents();\n      };\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = defaults.AUTO_ALIGNMENT) => {\n        const _states = vue.unref(states);\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = scroll.getScrollBarWidth(ns.namespace.value);\n        const _cache = vue.unref(cache);\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const {\n          columnWidth,\n          direction,\n          rowHeight\n        } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n        if (shared.hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, vue.unref(cache));\n          const _cache = vue.unref(cache);\n          const rtl = utils.isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        vue.nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      vue.onMounted(() => {\n        if (!core.isClient) return;\n        const {\n          initScrollLeft,\n          initScrollTop\n        } = props;\n        const windowElement = vue.unref(windowRef);\n        if (windowElement) {\n          if (types.isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n          if (types.isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n        emitEvents();\n      });\n      const onUpdated = () => {\n        const {\n          direction\n        } = props;\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested\n        } = vue.unref(states);\n        const windowElement = vue.unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (direction === defaults.RTL) {\n            switch (utils.getRTLOffsetType()) {\n              case defaults.RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n              case defaults.RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n              default:\n                {\n                  const {\n                    clientWidth,\n                    scrollWidth\n                  } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      };\n      const {\n        resetAfterColumnIndex,\n        resetAfterRowIndex,\n        resetAfter\n      } = instance.proxy;\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states,\n        resetAfterColumnIndex,\n        resetAfterRowIndex,\n        resetAfter\n      });\n      const renderScrollbars = () => {\n        const {\n          scrollbarAlwaysOn,\n          scrollbarStartGap,\n          scrollbarEndGap,\n          totalColumn,\n          totalRow\n        } = props;\n        const width = vue.unref(parsedWidth);\n        const height = vue.unref(parsedHeight);\n        const estimatedWidth = vue.unref(estimatedTotalWidth);\n        const estimatedHeight = vue.unref(estimatedTotalHeight);\n        const {\n          scrollLeft,\n          scrollTop\n        } = vue.unref(states);\n        const horizontalScrollbar = vue.h(scrollbar[\"default\"], {\n          ref: hScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e(\"horizontal\"),\n          clientSize: width,\n          layout: \"horizontal\",\n          onScroll: onHorizontalScroll,\n          ratio: width * 100 / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true\n        });\n        const verticalScrollbar = vue.h(scrollbar[\"default\"], {\n          ref: vScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e(\"vertical\"),\n          clientSize: height,\n          layout: \"vertical\",\n          onScroll: onVerticalScroll,\n          ratio: height * 100 / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true\n        });\n        return {\n          horizontalScrollbar,\n          verticalScrollbar\n        };\n      };\n      const renderItems = () => {\n        var _a;\n        const [columnStart, columnEnd] = vue.unref(columnsToRender);\n        const [rowStart, rowEnd] = vue.unref(rowsToRender);\n        const {\n          data,\n          totalColumn,\n          totalRow,\n          useIsScrolling,\n          itemKey\n        } = props;\n        const children = [];\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push((_a = slots.default) == null ? void 0 : _a.call(slots, {\n                columnIndex: column,\n                data,\n                key: itemKey({\n                  columnIndex: column,\n                  data,\n                  rowIndex: row\n                }),\n                isScrolling: useIsScrolling ? vue.unref(states).isScrolling : void 0,\n                style: getItemStyle(row, column),\n                rowIndex: row\n              }));\n            }\n          }\n        }\n        return children;\n      };\n      const renderInner = () => {\n        const Inner = vue.resolveDynamicComponent(props.innerElement);\n        const children = renderItems();\n        return [vue.h(Inner, {\n          style: vue.unref(innerStyle),\n          ref: innerRef\n        }, !shared.isString(Inner) ? {\n          default: () => children\n        } : children)];\n      };\n      const renderWindow = () => {\n        const Container = vue.resolveDynamicComponent(props.containerElement);\n        const {\n          horizontalScrollbar,\n          verticalScrollbar\n        } = renderScrollbars();\n        const Inner = renderInner();\n        return vue.h(\"div\", {\n          key: 0,\n          class: ns.e(\"wrapper\"),\n          role: props.role\n        }, [vue.h(Container, {\n          class: props.className,\n          style: vue.unref(windowStyle),\n          onScroll,\n          onWheel,\n          ref: windowRef\n        }, !shared.isString(Container) ? {\n          default: () => Inner\n        } : Inner), horizontalScrollbar, verticalScrollbar]);\n      };\n      return renderWindow;\n    }\n  });\n};\nexports[\"default\"] = createGrid;","map":{"version":3,"names":["createGrid","name","clearCache","getColumnPosition","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getEstimatedTotalHeight","getEstimatedTotalWidth","getColumnOffset","getRowOffset","getRowPosition","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initCache","injectToInstance","validateProps","vue","defineComponent","props","virtualizedGridProps","emits","defaults","ITEM_RENDER_EVT","SCROLL_EVT","setup","emit","expose","slots","ns","index","useNamespace","instance","getCurrentInstance","cache","ref","windowRef","hScrollbar","vScrollbar","innerRef","states","isScrolling","scrollLeft","types","isNumber","initScrollLeft","scrollTop","initScrollTop","updateRequested","xAxisScrollDir","FORWARD","yAxisScrollDir","getItemStyleCache","useCache","parsedHeight","computed","Number","parseInt","height","parsedWidth","width","columnsToRender","totalColumn","totalRow","columnCache","unref","startIndex","stopIndex","cacheBackward","BACKWARD","Math","max","cacheForward","min","rowsToRender","rowCache","estimatedTotalHeight","estimatedTotalWidth","windowStyle","_a","position","overflow","WebkitOverflowScrolling","willChange","direction","style","innerStyle","pointerEvents","emitEvents","columnCacheStart","columnCacheEnd","columnVisibleStart","columnVisibleEnd","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","onScroll","e","clientHeight","clientWidth","scrollHeight","scrollWidth","currentTarget","_states","_scrollLeft","utils","isRTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","value","getScrollDir","nextTick","resetIsScrolling","onUpdated","onVerticalScroll","distance","totalSteps","offset","scrollTo","onHorizontalScroll","onWheel","useGridWheel","atXStartEdge","atXEndEdge","atYStartEdge","atYEndEdge","x","y","_b","_c","_d","onMouseUp","call","scrollToItem","rowIndex","columnIdx","alignment","AUTO_ALIGNMENT","scrollBarWidth","scroll","getScrollBarWidth","namespace","_cache","estimatedHeight","estimatedWidth","getItemStyle","columnIndex","columnWidth","rowHeight","itemStyleCache","key","shared","hasOwn","left","rtl","top","right","onMounted","core","isClient","windowElement","RTL","RTL_OFFSET_POS_ASC","resetAfterColumnIndex","resetAfterRowIndex","resetAfter","proxy","renderScrollbars","scrollbarAlwaysOn","scrollbarStartGap","scrollbarEndGap","horizontalScrollbar","h","scrollbar","alwaysOn","startGap","endGap","class","clientSize","layout","ratio","scrollFrom","total","visible","verticalScrollbar","renderItems","columnStart","columnEnd","rowStart","rowEnd","data","useIsScrolling","itemKey","children","row","column","push","default","renderInner","Inner","resolveDynamicComponent","innerElement","isString","renderWindow","Container","containerElement","role","className"],"sources":["../../../../../../../packages/components/virtual-list/src/builders/build-grid.ts"],"sourcesContent":["// @ts-nocheck\nimport {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  h,\n  nextTick,\n  onMounted,\n  ref,\n  resolveDynamicComponent,\n  unref,\n} from 'vue'\nimport {\n  getScrollBarWidth,\n  hasOwn,\n  isClient,\n  isNumber,\n  isString,\n} from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport Scrollbar from '../components/scrollbar'\nimport { useGridWheel } from '../hooks/use-grid-wheel'\nimport { useCache } from '../hooks/use-cache'\nimport { virtualizedGridProps } from '../props'\nimport { getRTLOffsetType, getScrollDir, isRTL } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  ITEM_RENDER_EVT,\n  RTL,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_ASC,\n  RTL_OFFSET_POS_DESC,\n  SCROLL_EVT,\n} from '../defaults'\nimport type {\n  CSSProperties,\n  Ref,\n  StyleValue,\n  UnwrapRef,\n  VNode,\n  VNodeChild,\n} from 'vue'\nimport type {\n  Alignment,\n  GridConstructorProps,\n  GridScrollOptions,\n  ScrollbarExpose,\n} from '../types'\nimport type { VirtualizedGridProps } from '../props'\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n\n  initCache,\n  injectToInstance,\n  validateProps,\n}: GridConstructorProps<VirtualizedGridProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose, slots }) {\n      const ns = useNamespace('vl')\n\n      validateProps(props)\n      const instance = getCurrentInstance()!\n      const cache = ref(initCache(props, instance))\n      injectToInstance?.(instance, cache)\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const hScrollbar = ref<ScrollbarExpose>()\n      const vScrollbar = ref<ScrollbarExpose>()\n      // innerRef is the actual container element which contains all the elements\n      const innerRef = ref(null)\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD,\n      })\n\n      const getItemStyleCache = useCache()\n\n      // computed\n      const parsedHeight = computed(() =>\n        Number.parseInt(`${props.height}`, 10)\n      )\n      const parsedWidth = computed(() => Number.parseInt(`${props.width}`, 10))\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props\n        const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getColumnStartIndexForOffset(\n          props,\n          scrollLeft,\n          unref(cache)\n        )\n        const stopIndex = getColumnStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollLeft,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || xAxisScrollDir === BACKWARD\n            ? Math.max(1, columnCache)\n            : 1\n        const cacheForward =\n          !isScrolling || xAxisScrollDir === FORWARD\n            ? Math.max(1, columnCache)\n            : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props\n        const { isScrolling, yAxisScrollDir, scrollTop } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getRowStartIndexForOffset(\n          props,\n          scrollTop,\n          unref(cache)\n        )\n        const stopIndex = getRowStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollTop,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || yAxisScrollDir === BACKWARD\n            ? Math.max(1, rowCache)\n            : 1\n        const cacheForward =\n          !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalHeight = computed(() =>\n        getEstimatedTotalHeight(props, unref(cache))\n      )\n      const estimatedTotalWidth = computed(() =>\n        getEstimatedTotalWidth(props, unref(cache))\n      )\n\n      const windowStyle = computed<StyleValue>(() => [\n        {\n          position: 'relative',\n          overflow: 'hidden',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style ?? {},\n      ])\n\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`\n        const height = `${unref(estimatedTotalHeight)}px`\n\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width,\n        }\n      })\n\n      // methods\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props\n\n        if (totalColumn! > 0 && totalRow! > 0) {\n          const [\n            columnCacheStart,\n            columnCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n          ] = unref(columnsToRender)\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] =\n            unref(rowsToRender)\n          // emit the render item event with\n          // [xAxisInvisibleStart, xAxisInvisibleEnd, xAxisVisibleStart, xAxisVisibleEnd]\n          // [yAxisInvisibleStart, yAxisInvisibleEnd, yAxisVisibleStart, yAxisVisibleEnd]\n          emit(ITEM_RENDER_EVT, {\n            columnCacheStart,\n            columnCacheEnd,\n            rowCacheStart,\n            rowCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n            rowVisibleStart,\n            rowVisibleEnd,\n          })\n        }\n\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir,\n        } = unref(states)\n        emit(SCROLL_EVT, {\n          xAxisScrollDir,\n          scrollLeft,\n          yAxisScrollDir,\n          scrollTop,\n          updateRequested,\n        })\n      }\n\n      const onScroll = (e: Event) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth,\n        } = e.currentTarget as HTMLElement\n\n        const _states = unref(states)\n\n        if (\n          _states.scrollTop === scrollTop &&\n          _states.scrollLeft === scrollLeft\n        ) {\n          return\n        }\n\n        let _scrollLeft = scrollLeft\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft\n              break\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft\n              break\n          }\n        }\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(\n            0,\n            Math.min(scrollTop, scrollHeight - clientHeight)\n          ),\n          updateRequested: true,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n        }\n\n        nextTick(() => resetIsScrolling())\n\n        onUpdated()\n        emitEvents()\n      }\n\n      const onVerticalScroll = (distance: number, totalSteps: number) => {\n        const height = unref(parsedHeight)\n        const offset =\n          ((estimatedTotalHeight.value - height) / totalSteps) * distance\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset),\n        })\n      }\n\n      const onHorizontalScroll = (distance: number, totalSteps: number) => {\n        const width = unref(parsedWidth)\n        const offset =\n          ((estimatedTotalWidth.value - width) / totalSteps) * distance\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset),\n        })\n      }\n\n      const { onWheel } = useGridWheel(\n        {\n          atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n          atXEndEdge: computed(\n            () =>\n              states.value.scrollLeft >=\n              estimatedTotalWidth.value - unref(parsedWidth)\n          ),\n          atYStartEdge: computed(() => states.value.scrollTop <= 0),\n          atYEndEdge: computed(\n            () =>\n              states.value.scrollTop >=\n              estimatedTotalHeight.value - unref(parsedHeight)\n          ),\n        },\n        (x: number, y: number) => {\n          hScrollbar.value?.onMouseUp?.()\n          vScrollbar.value?.onMouseUp?.()\n          const width = unref(parsedWidth)\n          const height = unref(parsedHeight)\n          scrollTo({\n            scrollLeft: Math.min(\n              states.value.scrollLeft + x,\n              estimatedTotalWidth.value - width\n            ),\n            scrollTop: Math.min(\n              states.value.scrollTop + y,\n              estimatedTotalHeight.value - height\n            ),\n          })\n        }\n      )\n\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop,\n      }: GridScrollOptions) => {\n        scrollLeft = Math.max(scrollLeft, 0)\n        scrollTop = Math.max(scrollTop, 0)\n        const _states = unref(states)\n        if (\n          scrollTop === _states.scrollTop &&\n          scrollLeft === _states.scrollLeft\n        ) {\n          return\n        }\n\n        states.value = {\n          ..._states,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true,\n        }\n\n        nextTick(() => resetIsScrolling())\n\n        onUpdated()\n        emitEvents()\n      }\n\n      const scrollToItem = (\n        rowIndex = 0,\n        columnIdx = 0,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const _states = unref(states)\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn! - 1))\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow! - 1))\n        const scrollBarWidth = getScrollBarWidth(ns.namespace.value)\n\n        const _cache = unref(cache)\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache)\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache)\n\n        scrollTo({\n          scrollLeft: getColumnOffset(\n            props,\n            columnIdx,\n            alignment,\n            _states.scrollLeft,\n            _cache,\n            estimatedWidth > props.width! ? scrollBarWidth : 0\n          ),\n          scrollTop: getRowOffset(\n            props,\n            rowIndex,\n            alignment,\n            _states.scrollTop,\n            _cache,\n            estimatedHeight > props.height! ? scrollBarWidth : 0\n          ),\n        })\n      }\n\n      const getItemStyle = (\n        rowIndex: number,\n        columnIndex: number\n      ): CSSProperties => {\n        const { columnWidth, direction, rowHeight } = props\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && columnWidth,\n          clearCache && rowHeight,\n          clearCache && direction\n        )\n        // since there was no need to introduce an nested array into cache object\n        // we use row,column to construct the key for indexing the map.\n        const key = `${rowIndex},${columnIndex}`\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key]\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache))\n          const _cache = unref(cache)\n\n          const rtl = isRTL(direction)\n          const [height, top] = getRowPosition(props, rowIndex, _cache)\n          const [width] = getColumnPosition(props, columnIndex, _cache)\n\n          itemStyleCache[key] = {\n            position: 'absolute',\n            left: rtl ? undefined : `${left}px`,\n            right: rtl ? `${left}px` : undefined,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`,\n          }\n\n          return itemStyleCache[key]\n        }\n      }\n\n      // TODO: debounce setting is scrolling.\n\n      const resetIsScrolling = () => {\n        // timer = null\n\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      // life cycles\n      onMounted(() => {\n        // for SSR\n        if (!isClient) return\n        const { initScrollLeft, initScrollTop } = props\n        const windowElement = unref(windowRef)\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop\n          }\n        }\n        emitEvents()\n      })\n\n      const onUpdated = () => {\n        const { direction } = props\n        const { scrollLeft, scrollTop, updateRequested } = unref(states)\n\n        const windowElement = unref(windowRef)\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft\n                break\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft\n                break\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement\n                windowElement.scrollLeft =\n                  scrollWidth - clientWidth - scrollLeft\n                break\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft)\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop)\n        }\n      }\n\n      const { resetAfterColumnIndex, resetAfterRowIndex, resetAfter } =\n        instance.proxy as any\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states,\n        resetAfterColumnIndex,\n        resetAfterRowIndex,\n        resetAfter,\n      })\n\n      // rendering part\n\n      const renderScrollbars = () => {\n        const {\n          scrollbarAlwaysOn,\n          scrollbarStartGap,\n          scrollbarEndGap,\n          totalColumn,\n          totalRow,\n        } = props\n\n        const width = unref(parsedWidth)\n        const height = unref(parsedHeight)\n        const estimatedWidth = unref(estimatedTotalWidth)\n        const estimatedHeight = unref(estimatedTotalHeight)\n        const { scrollLeft, scrollTop } = unref(states)\n        const horizontalScrollbar = h(Scrollbar, {\n          ref: hScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e('horizontal'),\n          clientSize: width,\n          layout: 'horizontal',\n          onScroll: onHorizontalScroll,\n          ratio: (width * 100) / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true,\n        })\n\n        const verticalScrollbar = h(Scrollbar, {\n          ref: vScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e('vertical'),\n          clientSize: height,\n          layout: 'vertical',\n          onScroll: onVerticalScroll,\n          ratio: (height * 100) / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n\n          total: totalColumn,\n          visible: true,\n        })\n\n        return {\n          horizontalScrollbar,\n          verticalScrollbar,\n        }\n      }\n\n      const renderItems = () => {\n        const [columnStart, columnEnd] = unref(columnsToRender)\n        const [rowStart, rowEnd] = unref(rowsToRender)\n        const { data, totalColumn, totalRow, useIsScrolling, itemKey } = props\n        const children: VNodeChild[] = []\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push(\n                slots.default?.({\n                  columnIndex: column,\n                  data,\n                  key: itemKey({ columnIndex: column, data, rowIndex: row }),\n                  isScrolling: useIsScrolling\n                    ? unref(states).isScrolling\n                    : undefined,\n                  style: getItemStyle(row, column),\n                  rowIndex: row,\n                })\n              )\n            }\n          }\n        }\n        return children\n      }\n\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement) as VNode\n        const children = renderItems()\n        return [\n          h(\n            Inner,\n            {\n              style: unref(innerStyle),\n              ref: innerRef,\n            },\n            !isString(Inner)\n              ? {\n                  default: () => children,\n                }\n              : children\n          ),\n        ]\n      }\n\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(\n          props.containerElement\n        ) as VNode\n        const { horizontalScrollbar, verticalScrollbar } = renderScrollbars()\n        const Inner = renderInner()\n\n        return h(\n          'div',\n          {\n            key: 0,\n            class: ns.e('wrapper'),\n            role: props.role,\n          },\n          [\n            h(\n              Container,\n              {\n                class: props.className,\n                style: unref(windowStyle),\n                onScroll,\n                onWheel,\n                ref: windowRef,\n              },\n              !isString(Container) ? { default: () => Inner } : Inner\n            ),\n            horizontalScrollbar,\n            verticalScrollbar,\n          ]\n        )\n      }\n\n      return renderWindow\n    },\n  })\n}\n\nexport default createGrid\n\ntype Dir = typeof FORWARD | typeof BACKWARD\n\nexport type GridInstance = InstanceType<ReturnType<typeof createGrid>> &\n  UnwrapRef<{\n    windowRef: Ref<HTMLElement>\n    innerRef: Ref<HTMLElement>\n    getItemStyleCache: ReturnType<typeof useCache>\n    scrollTo: (scrollOptions: GridScrollOptions) => void\n    scrollToItem: (\n      rowIndex: number,\n      columnIndex: number,\n      alignment: Alignment\n    ) => void\n    states: Ref<{\n      isScrolling: boolean\n      scrollLeft: number\n      scrollTop: number\n      updateRequested: boolean\n      xAxisScrollDir: Dir\n      yAxisScrollDir: Dir\n    }>\n  }>\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}