{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar vue = require('vue');\nrequire('../../../../utils/index.js');\nrequire('../../../../hooks/index.js');\nvar useCache = require('../hooks/use-cache.js');\nvar useWheel = require('../hooks/use-wheel.js');\nvar scrollbar = require('../components/scrollbar.js');\nvar utils = require('../utils.js');\nvar props = require('../props.js');\nvar defaults = require('../defaults.js');\nvar index = require('../../../../hooks/use-namespace/index.js');\nvar types = require('../../../../utils/types.js');\nvar shared = require('@vue/shared');\nvar core = require('@vueuse/core');\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return vue.defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: props.virtualizedListProps,\n    emits: [defaults.ITEM_RENDER_EVT, defaults.SCROLL_EVT],\n    setup(props, {\n      emit,\n      expose\n    }) {\n      validateProps(props);\n      const instance = vue.getCurrentInstance();\n      const ns = index.useNamespace(\"vl\");\n      const dynamicSizeCache = vue.ref(initCache(props, instance));\n      const getItemStyleCache = useCache.useCache();\n      const windowRef = vue.ref();\n      const innerRef = vue.ref();\n      const scrollbarRef = vue.ref();\n      const states = vue.ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: types.isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn\n      });\n      const itemsToRender = vue.computed(() => {\n        const {\n          total,\n          cache\n        } = props;\n        const {\n          isScrolling,\n          scrollDir,\n          scrollOffset\n        } = vue.unref(states);\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getStartIndexForOffset(props, scrollOffset, vue.unref(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, vue.unref(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === defaults.BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === defaults.FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalSize = vue.computed(() => getEstimatedTotalSize(props, vue.unref(dynamicSizeCache)));\n      const _isHorizontal = vue.computed(() => utils.isHorizontal(props.layout));\n      const windowStyle = vue.computed(() => [{\n        position: \"relative\",\n        [`overflow-${_isHorizontal.value ? \"x\" : \"y\"}`]: \"scroll\",\n        WebkitOverflowScrolling: \"touch\",\n        willChange: \"transform\"\n      }, {\n        direction: props.direction,\n        height: types.isNumber(props.height) ? `${props.height}px` : props.height,\n        width: types.isNumber(props.width) ? `${props.width}px` : props.width\n      }, props.style]);\n      const innerStyle = vue.computed(() => {\n        const size = vue.unref(estimatedTotalSize);\n        const horizontal = vue.unref(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: vue.unref(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = vue.computed(() => _isHorizontal.value ? props.width : props.height);\n      const {\n        onWheel\n      } = useWheel[\"default\"]({\n        atStartEdge: vue.computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: vue.computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: vue.computed(() => props.layout)\n      }, offset => {\n        var _a, _b;\n        ;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n      const emitEvents = () => {\n        const {\n          total\n        } = props;\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = vue.unref(itemsToRender);\n          emit(defaults.ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n        const {\n          scrollDir,\n          scrollOffset,\n          updateRequested\n        } = vue.unref(states);\n        emit(defaults.SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n      const scrollVertically = e => {\n        const {\n          clientHeight,\n          scrollHeight,\n          scrollTop\n        } = e.currentTarget;\n        const _states = vue.unref(states);\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: utils.getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        };\n        vue.nextTick(resetIsScrolling);\n      };\n      const scrollHorizontally = e => {\n        const {\n          clientWidth,\n          scrollLeft,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = vue.unref(states);\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n        const {\n          direction\n        } = props;\n        let scrollOffset = scrollLeft;\n        if (direction === defaults.RTL) {\n          switch (utils.getRTLOffsetType()) {\n            case defaults.RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n            case defaults.RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: utils.getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        };\n        vue.nextTick(resetIsScrolling);\n      };\n      const onScroll = e => {\n        vue.unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n      const scrollTo = offset => {\n        offset = Math.max(offset, 0);\n        if (offset === vue.unref(states).scrollOffset) {\n          return;\n        }\n        states.value = {\n          ...vue.unref(states),\n          scrollOffset: offset,\n          scrollDir: utils.getScrollDir(vue.unref(states).scrollOffset, offset),\n          updateRequested: true\n        };\n        vue.nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (idx, alignment = defaults.AUTO_ALIGNMENT) => {\n        const {\n          scrollOffset\n        } = vue.unref(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, vue.unref(dynamicSizeCache)));\n      };\n      const getItemStyle = idx => {\n        const {\n          direction,\n          itemSize,\n          layout\n        } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n        if (shared.hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, vue.unref(dynamicSizeCache));\n          const size = getItemSize(props, idx, vue.unref(dynamicSizeCache));\n          const horizontal = vue.unref(_isHorizontal);\n          const isRtl = direction === defaults.RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n        return style;\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        vue.nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      const resetScrollTop = () => {\n        const window = windowRef.value;\n        if (window) {\n          window.scrollTop = 0;\n        }\n      };\n      vue.onMounted(() => {\n        if (!core.isClient) return;\n        const {\n          initScrollOffset\n        } = props;\n        const windowElement = vue.unref(windowRef);\n        if (types.isNumber(initScrollOffset) && windowElement) {\n          if (vue.unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n        emitEvents();\n      });\n      vue.onUpdated(() => {\n        const {\n          direction,\n          layout\n        } = props;\n        const {\n          scrollOffset,\n          updateRequested\n        } = vue.unref(states);\n        const windowElement = vue.unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (layout === defaults.HORIZONTAL) {\n            if (direction === defaults.RTL) {\n              switch (utils.getRTLOffsetType()) {\n                case defaults.RTL_OFFSET_NAG:\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n                case defaults.RTL_OFFSET_POS_ASC:\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n                default:\n                  {\n                    const {\n                      clientWidth,\n                      scrollWidth\n                    } = windowElement;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        ns,\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle,\n        ns\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = vue.resolveDynamicComponent(containerElement);\n      const Inner = vue.resolveDynamicComponent(innerElement);\n      const children = [];\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n      const InnerNode = [vue.h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !shared.isString(Inner) ? {\n        default: () => children\n      } : children)];\n      const scrollbar$1 = vue.h(scrollbar[\"default\"], {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total\n      });\n      const listContainer = vue.h(Container, {\n        class: [ns.e(\"window\"), className],\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !shared.isString(Container) ? {\n        default: () => [InnerNode]\n      } : [InnerNode]);\n      return vue.h(\"div\", {\n        key: 0,\n        class: [ns.e(\"wrapper\"), states.scrollbarAlwaysOn ? \"always-on\" : \"\"]\n      }, [listContainer, scrollbar$1]);\n    }\n  });\n};\nexports[\"default\"] = createList;","map":{"version":3,"names":["createList","name","getOffset","getItemSize","getItemOffset","getEstimatedTotalSize","getStartIndexForOffset","getStopIndexForStartIndex","initCache","clearCache","validateProps","vue","defineComponent","props","virtualizedListProps","emits","defaults","ITEM_RENDER_EVT","SCROLL_EVT","setup","emit","expose","instance","getCurrentInstance","ns","index","useNamespace","dynamicSizeCache","ref","getItemStyleCache","useCache","windowRef","innerRef","scrollbarRef","states","isScrolling","scrollDir","scrollOffset","types","isNumber","initScrollOffset","updateRequested","isScrollbarDragging","scrollbarAlwaysOn","itemsToRender","computed","total","cache","unref","startIndex","stopIndex","cacheBackward","BACKWARD","Math","max","cacheForward","FORWARD","min","estimatedTotalSize","_isHorizontal","utils","isHorizontal","layout","windowStyle","position","value","WebkitOverflowScrolling","willChange","direction","height","width","style","innerStyle","size","horizontal","pointerEvents","clientSize","onWheel","useWheel","atStartEdge","atEndEdge","offset","_a","_b","onMouseUp","call","scrollTo","emitEvents","cacheStart","cacheEnd","visibleStart","visibleEnd","scrollVertically","e","clientHeight","scrollHeight","scrollTop","currentTarget","_states","getScrollDir","nextTick","resetIsScrolling","scrollHorizontally","clientWidth","scrollLeft","scrollWidth","RTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","onScroll","onScrollbarScroll","distanceToGo","totalSteps","scrollToItem","idx","alignment","AUTO_ALIGNMENT","getItemStyle","itemSize","itemStyleCache","shared","hasOwn","String","isRtl","offsetHorizontal","left","right","top","resetScrollTop","window","onMounted","core","isClient","windowElement","onUpdated","HORIZONTAL","RTL_OFFSET_POS_ASC","api","render","ctx","$slots","className","containerElement","data","innerElement","useIsScrolling","start","end","Container","resolveDynamicComponent","Inner","children","i","push","default","key","InnerNode","h","isString","scrollbar$1","scrollbar","ratio","scrollFrom","listContainer","class"],"sources":["../../../../../../../packages/components/virtual-list/src/builders/build-list.ts"],"sourcesContent":["// @ts-nocheck\nimport {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  h,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  resolveDynamicComponent,\n  unref,\n} from 'vue'\nimport { hasOwn, isClient, isNumber, isString } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { useCache } from '../hooks/use-cache'\nimport useWheel from '../hooks/use-wheel'\nimport Scrollbar from '../components/scrollbar'\nimport { getRTLOffsetType, getScrollDir, isHorizontal } from '../utils'\nimport { virtualizedListProps } from '../props'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  HORIZONTAL,\n  ITEM_RENDER_EVT,\n  RTL,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_ASC,\n  RTL_OFFSET_POS_DESC,\n  SCROLL_EVT,\n} from '../defaults'\n\nimport type { CSSProperties, Slot, VNode, VNodeChild } from 'vue'\nimport type { Alignment, ListConstructorProps } from '../types'\nimport type { VirtualizedListProps } from '../props'\n\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps,\n}: ListConstructorProps<VirtualizedListProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props)\n      const instance = getCurrentInstance()!\n\n      const ns = useNamespace('vl')\n\n      const dynamicSizeCache = ref(initCache(props, instance))\n\n      const getItemStyleCache = useCache()\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const innerRef = ref<HTMLElement>()\n      const scrollbarRef = ref()\n      const states = ref({\n        isScrolling: false,\n        scrollDir: 'forward',\n        scrollOffset: isNumber(props.initScrollOffset)\n          ? props.initScrollOffset\n          : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn,\n      })\n\n      // computed\n      const itemsToRender = computed(() => {\n        const { total, cache } = props\n        const { isScrolling, scrollDir, scrollOffset } = unref(states)\n\n        if (total === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getStartIndexForOffset(\n          props,\n          scrollOffset,\n          unref(dynamicSizeCache)\n        )\n        const stopIndex = getStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollOffset,\n          unref(dynamicSizeCache)\n        )\n\n        const cacheBackward =\n          !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1\n        const cacheForward =\n          !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(total! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalSize = computed(() =>\n        getEstimatedTotalSize(props, unref(dynamicSizeCache))\n      )\n\n      const _isHorizontal = computed(() => isHorizontal(props.layout))\n\n      const windowStyle = computed(() => [\n        {\n          position: 'relative',\n          [`overflow-${_isHorizontal.value ? 'x' : 'y'}`]: 'scroll',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style,\n      ])\n\n      const innerStyle = computed(() => {\n        const size = unref(estimatedTotalSize)\n        const horizontal = unref(_isHorizontal)\n        return {\n          height: horizontal ? '100%' : `${size}px`,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width: horizontal ? `${size}px` : '100%',\n        }\n      })\n\n      const clientSize = computed(() =>\n        _isHorizontal.value ? props.width : props.height\n      )\n\n      // methods\n      const { onWheel } = useWheel(\n        {\n          atStartEdge: computed(() => states.value.scrollOffset <= 0),\n          atEndEdge: computed(\n            () => states.value.scrollOffset >= estimatedTotalSize.value\n          ),\n          layout: computed(() => props.layout),\n        },\n        (offset) => {\n          ;(\n            scrollbarRef.value as any as {\n              onMouseUp: () => void\n            }\n          ).onMouseUp?.()\n          scrollTo(\n            Math.min(\n              states.value.scrollOffset + offset,\n              estimatedTotalSize.value - (clientSize.value as number)\n            )\n          )\n        }\n      )\n\n      const emitEvents = () => {\n        const { total } = props\n\n        if (total! > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] =\n            unref(itemsToRender)\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd)\n        }\n\n        const { scrollDir, scrollOffset, updateRequested } = unref(states)\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested)\n      }\n\n      const scrollVertically = (e: Event) => {\n        const { clientHeight, scrollHeight, scrollTop } =\n          e.currentTarget as HTMLElement\n        const _states = unref(states)\n        if (_states.scrollOffset === scrollTop) {\n          return\n        }\n\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        )\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollHorizontally = (e: Event) => {\n        const { clientWidth, scrollLeft, scrollWidth } =\n          e.currentTarget as HTMLElement\n        const _states = unref(states)\n\n        if (_states.scrollOffset === scrollLeft) {\n          return\n        }\n\n        const { direction } = props\n\n        let scrollOffset = scrollLeft\n\n        if (direction === RTL) {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG: {\n              scrollOffset = -scrollLeft\n              break\n            }\n            case RTL_OFFSET_POS_DESC: {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft\n              break\n            }\n          }\n        }\n\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        )\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const onScroll = (e: Event) => {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e)\n        emitEvents()\n      }\n\n      const onScrollbarScroll = (distanceToGo: number, totalSteps: number) => {\n        const offset =\n          ((estimatedTotalSize.value - (clientSize.value as number)) /\n            totalSteps) *\n          distanceToGo\n        scrollTo(\n          Math.min(\n            estimatedTotalSize.value - (clientSize.value as number),\n            offset\n          )\n        )\n      }\n\n      const scrollTo = (offset: number) => {\n        offset = Math.max(offset, 0)\n\n        if (offset === unref(states).scrollOffset) {\n          return\n        }\n\n        states.value = {\n          ...unref(states),\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollToItem = (\n        idx: number,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const { scrollOffset } = unref(states)\n\n        idx = Math.max(0, Math.min(idx, props.total! - 1))\n        scrollTo(\n          getOffset(\n            props,\n            idx,\n            alignment,\n            scrollOffset,\n            unref(dynamicSizeCache)\n          )\n        )\n      }\n\n      const getItemStyle = (idx: number) => {\n        const { direction, itemSize, layout } = props\n\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && itemSize,\n          clearCache && layout,\n          clearCache && direction\n        )\n\n        let style: CSSProperties\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx]\n        } else {\n          const offset = getItemOffset(props, idx, unref(dynamicSizeCache))\n          const size = getItemSize(props, idx, unref(dynamicSizeCache))\n          const horizontal = unref(_isHorizontal)\n\n          const isRtl = direction === RTL\n          const offsetHorizontal = horizontal ? offset : 0\n          itemStyleCache[idx] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : undefined,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : '100%',\n            width: horizontal ? `${size}px` : '100%',\n          }\n        }\n\n        return style\n      }\n\n      // TODO:\n      // perf optimization here, reset isScrolling with debounce.\n\n      const resetIsScrolling = () => {\n        // timer = null\n\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      const resetScrollTop = () => {\n        const window = windowRef.value\n        if (window) {\n          window.scrollTop = 0\n        }\n      }\n\n      // life cycles\n      onMounted(() => {\n        if (!isClient) return\n        const { initScrollOffset } = props\n        const windowElement = unref(windowRef)\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset\n          } else {\n            windowElement.scrollTop = initScrollOffset\n          }\n        }\n\n        emitEvents()\n      })\n\n      onUpdated(() => {\n        const { direction, layout } = props\n        const { scrollOffset, updateRequested } = unref(states)\n        const windowElement = unref(windowRef)\n\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n              // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n              // So we need to determine which browser behavior we're dealing with, and mimic it.\n              switch (getRTLOffsetType()) {\n                case RTL_OFFSET_NAG: {\n                  windowElement.scrollLeft = -scrollOffset\n                  break\n                }\n                case RTL_OFFSET_POS_ASC: {\n                  windowElement.scrollLeft = scrollOffset\n                  break\n                }\n                default: {\n                  const { clientWidth, scrollWidth } = windowElement\n                  windowElement.scrollLeft =\n                    scrollWidth - clientWidth - scrollOffset\n                  break\n                }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset\n          }\n        }\n      })\n\n      const api = {\n        ns,\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n      }\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states,\n      })\n\n      return api\n    },\n\n    render(ctx: any) {\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle,\n        ns,\n      } = ctx\n\n      const [start, end] = itemsToRender\n\n      const Container = resolveDynamicComponent(containerElement)\n      const Inner = resolveDynamicComponent(innerElement)\n\n      const children = [] as VNodeChild[]\n\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push(\n            ($slots.default as Slot)?.({\n              data,\n              key: i,\n              index: i,\n              isScrolling: useIsScrolling ? states.isScrolling : undefined,\n              style: getItemStyle(i),\n            })\n          )\n        }\n      }\n\n      const InnerNode = [\n        h(\n          Inner as VNode,\n          {\n            style: innerStyle,\n            ref: 'innerRef',\n          },\n          !isString(Inner)\n            ? {\n                default: () => children,\n              }\n            : children\n        ),\n      ]\n\n      const scrollbar = h(Scrollbar, {\n        ref: 'scrollbarRef',\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: (clientSize * 100) / this.estimatedTotalSize,\n        scrollFrom:\n          states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n      })\n\n      const listContainer = h(\n        Container as VNode,\n        {\n          class: [ns.e('window'), className],\n          style: windowStyle,\n          onScroll,\n          onWheel,\n          ref: 'windowRef',\n          key: 0,\n        },\n        !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]\n      )\n\n      return h(\n        'div',\n        {\n          key: 0,\n          class: [ns.e('wrapper'), states.scrollbarAlwaysOn ? 'always-on' : ''],\n        },\n        [listContainer, scrollbar]\n      )\n    },\n  })\n}\n\nexport default createList\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}